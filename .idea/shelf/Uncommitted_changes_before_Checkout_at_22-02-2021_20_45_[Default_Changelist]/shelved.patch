Index: app/src/main/kotlin/com/shakeshack/android/data/authentication/AuthenticationRepository.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.shakeshack.android.data.authentication\r\n\r\nimport com.shakeshack.android.BuildConfig\r\nimport com.shakeshack.android.data.authentication.api.AuthenticationApi\r\nimport com.shakeshack.android.data.authentication.api.OloUserAccountApi\r\nimport com.shakeshack.android.data.authentication.api.UserAccountApi\r\nimport com.shakeshack.android.data.authentication.model.*\r\nimport com.shakeshack.android.data.di.module.IoDispatcher\r\nimport com.shakeshack.android.data.repository.Result\r\nimport kotlinx.coroutines.CoroutineDispatcher\r\nimport kotlinx.coroutines.Dispatchers\r\nimport kotlinx.coroutines.flow.Flow\r\nimport kotlinx.coroutines.flow.flow\r\nimport kotlinx.coroutines.flow.flowOn\r\nimport okhttp3.Credentials\r\nimport okhttp3.ResponseBody\r\nimport javax.inject.Inject\r\nimport javax.inject.Singleton\r\n\r\n/**\r\n * Class that requests authentication and user information from the remote data source and\r\n * maintains an in-memory cache of login status and user credentials information.\r\n */\r\n\r\n@Singleton\r\nclass AuthenticationRepository @Inject constructor(\r\n    private val authenticationApi: AuthenticationApi,\r\n    private val userAccountApi: UserAccountApi,\r\n    private val oloUserAccountApi: OloUserAccountApi,\r\n    @IoDispatcher private val dispatcher: CoroutineDispatcher\r\n) {\r\n\r\n    //region In-memory caches...\r\n    // If user credentials will be cached in local storage, it is recommended it be encrypted\r\n    // @see https://developer.android.com/training/articles/keystore\r\n    private var userAuthentication: UserAuthentication? = null\r\n    private var userData: UserData? = null\r\n    private var oloAuthenticationResponse: OloAuthenticationResponse? = null\r\n    private var contactDetails: OloUserContactDetailsResponse? = null\r\n    private var forgottenPasswordData: ResponseBody? = null\r\n    //endregion\r\n\r\n    private val basicAuthHeader: String by lazy {\r\n        Credentials.basic(BuildConfig.SSMA_CLIENT_ID, BuildConfig.SSMA_CLIENT_SECRET)\r\n    }\r\n\r\n    fun logout() {\r\n        userAuthentication = null\r\n        userData = null\r\n        contactDetails = null\r\n        // TODO add logout API call when available\r\n    }\r\n\r\n    suspend fun userProfileLookup(username: String): Flow<Result<UserProfileLookupResponse>> {\r\n        return flow {\r\n            emit(Result.Loading(true))\r\n\r\n            val result = try {\r\n                val response = userAccountApi.userProfileLookup(\r\n                    basicAuthHeader,\r\n                    UserProfileLookupRequest(email = username)\r\n                )\r\n                Result.Success(response)\r\n            } catch (e: Exception) {\r\n                Result.Error(e)\r\n            }\r\n\r\n            emit(Result.Loading(false))\r\n\r\n            emit(result)\r\n        }.flowOn(dispatcher)\r\n    }\r\n\r\n    suspend fun login(\r\n        grantType: String,\r\n        username: String,\r\n        password: String\r\n    ): Flow<Result<UserAuthentication>> {\r\n\r\n        return flow {\r\n            emit(Result.Loading(true))\r\n            val result = try {\r\n                val response =\r\n                    authenticationApi.getToken(basicAuthHeader, grantType, username, password)\r\n                Result.Success(response)\r\n            } catch (e: Exception) {\r\n                Result.Error(e)\r\n            }\r\n            emit(Result.Loading(false))\r\n\r\n            if (result is Result.Success) {\r\n                userAuthentication = result.data\r\n            }\r\n\r\n            emit(result)\r\n        }.flowOn(dispatcher)\r\n    }\r\n\r\n    suspend fun refreshToken(\r\n        grantType: String,\r\n        refreshToken: String\r\n    ): Flow<Result<UserAuthentication>> {\r\n        return flow {\r\n            emit(Result.Loading(true))\r\n            val result = try {\r\n                val response =\r\n                    authenticationApi.getRefreshToken(basicAuthHeader, grantType, refreshToken)\r\n                Result.Success(response)\r\n            } catch (e: Exception) {\r\n                Result.Error(e)\r\n            }\r\n            emit(Result.Loading(false))\r\n\r\n            if (result is Result.Success) {\r\n                userAuthentication = result.data\r\n            }\r\n\r\n            emit(result)\r\n        }.flowOn(dispatcher)\r\n    }\r\n\r\n    suspend fun updateUserName(\r\n        authHeader: String,\r\n        id: Int,\r\n        firstName: String,\r\n        lastName: String,\r\n    ): Flow<Result<UserData>> {\r\n        return flow {\r\n            emit(Result.Loading(true))\r\n            val result = try {\r\n                val updateBody = UpdateUserRequest(UpdateUserNameRequest(firstName, lastName))\r\n                val response =\r\n                    userAccountApi.userProfileUpdate(\"Bearer $authHeader\", id, updateBody)\r\n                Result.Success(response)\r\n            } catch (e: Exception) {\r\n                Result.Error(e)\r\n            }\r\n            emit(Result.Loading(false))\r\n\r\n            emit(result)\r\n        }.flowOn(dispatcher)\r\n    }\r\n\r\n    suspend fun getUserData(authHeader: String): Flow<Result<UserData>> {\r\n        return flow {\r\n            // Return cache first, if available:\r\n            userData?.let {\r\n                emit(Result.Success(it))\r\n                return@flow\r\n            }\r\n\r\n            emit(Result.Loading(true))\r\n\r\n            val result = try {\r\n                val response = userAccountApi.getUserData(authHeader)\r\n                Result.Success(response)\r\n            } catch (e: Exception) {\r\n                Result.Error(e)\r\n            }\r\n\r\n            emit(Result.Loading(false))\r\n\r\n            if (result is Result.Success) {\r\n                userData = result.data\r\n            }\r\n\r\n            emit(result)\r\n        }.flowOn(dispatcher)\r\n    }\r\n\r\n    suspend fun getOloToken(\r\n        oloKey: String,\r\n        oloAuthenticationRequest: OloAuthenticationRequest\r\n    ): Flow<Result<OloAuthenticationResponse>> {\r\n        return flow {\r\n            // Return cache first, if available:\r\n            oloAuthenticationResponse?.let {\r\n                emit(Result.Success(it))\r\n                return@flow\r\n            }\r\n\r\n            emit(Result.Loading(true))\r\n\r\n            val result = try {\r\n                val response =\r\n                    oloUserAccountApi.getOrCreateOloUser(oloKey, oloAuthenticationRequest)\r\n                Result.Success(response)\r\n            } catch (e: Exception) {\r\n                Result.Error(e)\r\n            }\r\n\r\n            emit(Result.Loading(false))\r\n\r\n            if (result is Result.Success) {\r\n                oloAuthenticationResponse = result.data\r\n            }\r\n            emit(result)\r\n        }.flowOn(dispatcher)\r\n    }\r\n\r\n    suspend fun updateOloUserContactDetail(\r\n        oloAuthToken: String,\r\n        oloKey: String,\r\n        contactNumber: String\r\n    ): Flow<Result<OloUserContactDetailsResponse>> {\r\n        return flow {\r\n            emit(Result.Loading(true))\r\n            val result = try {\r\n                val response = oloUserAccountApi.updateOloContactDetails(\r\n                    oloAuthToken, oloKey,\r\n                    UpdateOloContactDetailsRequest(contactNumber)\r\n                )\r\n                Result.Success(response)\r\n            } catch (e: Exception) {\r\n                Result.Error(e)\r\n            }\r\n\r\n            emit(Result.Loading(false))\r\n\r\n            emit(result)\r\n        }.flowOn(dispatcher)\r\n    }\r\n\r\n    suspend fun getOloUserContactDetails(\r\n        oloAuthToken: String,\r\n        oloKey: String\r\n    ): Flow<Result<OloUserContactDetailsResponse>> {\r\n        return flow {\r\n            // Return cache first, if available:\r\n            contactDetails?.let {\r\n                emit(Result.Success(it))\r\n                return@flow\r\n            }\r\n\r\n            emit(Result.Loading(true))\r\n\r\n            val result = try {\r\n                val response = oloUserAccountApi.getOloContactDetails(oloAuthToken, oloKey)\r\n                Result.Success(response)\r\n            } catch (e: Exception) {\r\n                Result.Error(e)\r\n            }\r\n\r\n            emit(Result.Loading(false))\r\n\r\n            if (result is Result.Success) {\r\n                contactDetails = result.data\r\n            }\r\n            emit(result)\r\n        }.flowOn(dispatcher)\r\n    }\r\n\r\n\r\n    suspend fun requestPasswordRecovery(email: String): Flow<Result<ResponseBody>> {\r\n        return flow {\r\n\r\n            emit(Result.Loading(true))\r\n\r\n            val result = try {\r\n                val response = authenticationApi.requestPasswordRecovery(basicAuthHeader, email)\r\n\r\n                Result.Success(response)\r\n            } catch (e: Exception) {\r\n                Result.Error(e)\r\n            }\r\n\r\n            emit(Result.Loading(false))\r\n\r\n            if (result is Result.Success) {\r\n                forgottenPasswordData = result.data\r\n            }\r\n            emit(result)\r\n        }.flowOn(dispatcher)\r\n    }\r\n\r\n    suspend fun googleSignIn(grantType: String, tokenId: String): Flow<Result<UserAuthentication>> {\r\n        return flow {\r\n            emit(Result.Loading(true))\r\n            val result = try {\r\n                val response = authenticationApi.googleSignIn(basicAuthHeader, grantType, tokenId)\r\n                Result.Success(response)\r\n            } catch (exception: Exception) {\r\n                Result.Error(exception)\r\n            }\r\n            emit(Result.Loading(false))\r\n\r\n            if (result is Result.Success) {\r\n                userAuthentication = result.data\r\n            }\r\n\r\n            emit(result)\r\n        }.flowOn(dispatcher)\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/kotlin/com/shakeshack/android/data/authentication/AuthenticationRepository.kt	(revision 6396c08199df34293a1c2b5c227fa25e4f804cc7)
+++ app/src/main/kotlin/com/shakeshack/android/data/authentication/AuthenticationRepository.kt	(date 1614006151494)
@@ -277,7 +277,11 @@
         return flow {
             emit(Result.Loading(true))
             val result = try {
-                val response = authenticationApi.googleSignIn(basicAuthHeader, grantType, tokenId)
+                val response = authenticationApi.googleSignIn(
+                    authorization = basicAuthHeader,
+                    grantType = grantType,
+                    tokenId = tokenId
+                )
                 Result.Success(response)
             } catch (exception: Exception) {
                 Result.Error(exception)
Index: app/src/main/kotlin/com/shakeshack/android/data/authentication/api/AuthenticationApi.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.shakeshack.android.data.authentication.api\r\n\r\nimport com.shakeshack.android.data.authentication.model.UserAuthentication\r\nimport okhttp3.ResponseBody\r\nimport retrofit2.http.*\r\n\r\ninterface AuthenticationApi {\r\n\r\n    @FormUrlEncoded\r\n    @POST(\"token/\")\r\n    suspend fun getToken(\r\n        @Header(\"Authorization\") authorization: String,\r\n        @Field(\"grant_type\") grantType: String,\r\n        @Field(\"username\", encoded = true) username: String,\r\n        @Field(\"password\") password: String\r\n    ): UserAuthentication\r\n\r\n    @FormUrlEncoded\r\n    @POST(\"token/\")\r\n    suspend fun getRefreshToken(\r\n        @Header(\"Authorization\") authorization: String,\r\n        @Field(\"grant_type\") grantType: String,\r\n        @Field(\"refresh_token\") password: String\r\n    ): UserAuthentication\r\n\r\n    @FormUrlEncoded\r\n\r\n    @POST(\"login/google/\")\r\n    suspend fun googleSignIn(\r\n        @Header(\"Authorization\") authorization: String,\r\n        @Field(\"grant_type\", encoded = true) grantType: String,\r\n        @Field(\"id_token\",encoded = true) tokenId: String\r\n    ): UserAuthentication\r\n\r\n    @POST(\"forgotten/\")\r\n    suspend fun requestPasswordRecovery(\r\n        @Header(\"Authorization\") authorization: String,\r\n        @Field(\"email\") email: String\r\n    ):ResponseBody\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/kotlin/com/shakeshack/android/data/authentication/api/AuthenticationApi.kt	(revision 6396c08199df34293a1c2b5c227fa25e4f804cc7)
+++ app/src/main/kotlin/com/shakeshack/android/data/authentication/api/AuthenticationApi.kt	(date 1614006079147)
@@ -29,6 +29,8 @@
     suspend fun googleSignIn(
         @Header("Authorization") authorization: String,
         @Field("grant_type", encoded = true) grantType: String,
+        @Header("Platform-Version") platformVersion: String = "1.7.4", // TODO update with version
+        @Header("Platform-OS") platformOS: String = "android", // TODO update later
         @Field("id_token",encoded = true) tokenId: String
     ): UserAuthentication
 
Index: app/src/main/kotlin/com/shakeshack/android/presentation/account/fragment/AccountOverviewFragment.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.shakeshack.android.presentation.account.fragment\r\n\r\nimport android.os.Bundle\r\nimport android.view.LayoutInflater\r\nimport android.view.View\r\nimport android.view.ViewGroup\r\nimport androidx.constraintlayout.widget.ConstraintLayout\r\nimport androidx.fragment.app.activityViewModels\r\nimport androidx.lifecycle.Observer\r\nimport androidx.lifecycle.asLiveData\r\nimport androidx.navigation.fragment.findNavController\r\nimport com.shakeshack.android.R\r\nimport com.shakeshack.android.data.authentication.AccountPreferencesRepository\r\nimport com.shakeshack.android.databinding.FragmentAccountOverviewBinding\r\nimport com.shakeshack.android.presentation.account.viewmodel.AccountOverviewViewModel\r\nimport com.shakeshack.android.presentation.base.BaseFragment\r\nimport com.shakeshack.android.util.ui.ViewUtils\r\nimport dagger.hilt.android.AndroidEntryPoint\r\n\r\n@AndroidEntryPoint\r\nclass AccountOverviewFragment : BaseFragment() {\r\n    private var _binding: FragmentAccountOverviewBinding? = null\r\n    private val binding get() = _binding!!\r\n\r\n    private val viewModel: AccountOverviewViewModel by activityViewModels()\r\n\r\n    override fun onCreateView(\r\n        inflater: LayoutInflater,\r\n        container: ViewGroup?,\r\n        savedInstanceState: Bundle?\r\n    ): View? {\r\n        _binding = FragmentAccountOverviewBinding.inflate(inflater, container, false)\r\n        return binding.root\r\n    }\r\n\r\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\r\n        super.onViewCreated(view, savedInstanceState)\r\n\r\n        val accountPreferences = AccountPreferencesRepository(requireContext())\r\n        accountPreferences.authToken.asLiveData().observe(viewLifecycleOwner, Observer {\r\n            val authToken = it ?: return@Observer\r\n            viewModel.getUserData(authToken)\r\n        })\r\n\r\n        binding.apply {\r\n\r\n            setUpToolbarFromFragment(toolbarContainer.toolbar)\r\n            viewModel.orderHistoryItems.observe(viewLifecycleOwner, { orderHistoryItems ->\r\n                if (orderHistoryItems.isEmpty()) {\r\n                    orderHistoryOverviewContainer.itemName.text = getString(R.string.none)\r\n                } else {\r\n                    orderHistoryItems.first().let { lastOrderItem ->\r\n                        orderHistoryOverviewContainer.itemName.text = lastOrderItem.name\r\n                        orderHistoryOverviewContainer.itemOrderDate.text = lastOrderItem.dateOrdered\r\n                        lastOrderItem.image?.let {\r\n                            ViewUtils.loadImage(\r\n                                it,\r\n                                orderHistoryOverviewContainer.tray.trayFoodItem1\r\n                            )\r\n                        }\r\n                    }\r\n                }\r\n            })\r\n\r\n            profileContainer.propertyTitle.text = getString(R.string.profile)\r\n            viewModel.userProfile.observe(viewLifecycleOwner, { userProfile ->\r\n                profileContainer.propertyDescription.text =\r\n                    userProfile.getShortSummaryForAccountOverview()\r\n            })\r\n\r\n            paymentMethodsContainer.propertyTitle.text = getString(R.string.payment_methods)\r\n            viewModel.paymentMethods.observe(viewLifecycleOwner, { paymentMethods ->\r\n                if (paymentMethods.isEmpty()) {\r\n                    paymentMethodsContainer.propertyDescription.text = getString(R.string.none)\r\n                } else {\r\n                    paymentMethodsContainer.propertyDescription.text = paymentMethods.joinToString {\r\n                        getString(\r\n                            R.string.generic_title_and_description,\r\n                            it.name,\r\n                            it.lastFour\r\n                        )\r\n                    }\r\n\r\n                    paymentMethodsContainer.propertyDescription\r\n                        .setCompoundDrawablesRelativeWithIntrinsicBounds(\r\n                            R.drawable.ic_vector_mastercard, 0, 0, 0\r\n                        )\r\n                }\r\n            })\r\n\r\n            addressesContainer.propertyTitle.text = getString(R.string.addresses)\r\n            viewModel.addresses.observe(viewLifecycleOwner, { addresses ->\r\n                addressesContainer.propertyDescription.text =\r\n                    if (addresses.isEmpty()) {\r\n                        getString(R.string.none)\r\n                    } else {\r\n                        addresses.joinToString {\r\n                            getString(\r\n                                R.string.generic_title_and_description,\r\n                                it.name,\r\n                                it.firstLine\r\n                            )\r\n                        }\r\n                    }\r\n            })\r\n\r\n            allergensContainer.propertyTitle.text = getString(R.string.allergens)\r\n            viewModel.allergens.observe(viewLifecycleOwner, { selectedAllergens ->\r\n                allergensContainer.propertyDescription.text =\r\n                    if (selectedAllergens.isEmpty()) {\r\n                        getString(R.string.none_selected)\r\n                    } else {\r\n                        selectedAllergens\r\n                            .filter { it.itemName != null }\r\n                            .joinToString { it.itemName!! }\r\n                    }\r\n            })\r\n\r\n            profileContainer.topSeparator.apply {\r\n                layoutParams =\r\n                    ConstraintLayout.LayoutParams(\r\n                        ConstraintLayout.LayoutParams.MATCH_PARENT,\r\n                        requireContext().resources.getDimensionPixelSize(R.dimen.size_4dp)\r\n                    )\r\n                visibility = View.VISIBLE\r\n            }\r\n\r\n            listOf(\r\n                orderHistoryOverviewViewAllLink,\r\n                orderHistoryOverviewContainer.wholeLayout\r\n            ).forEach {\r\n                it.setOnClickListener {\r\n                    findNavController().navigate(R.id.order_history_action)\r\n                }\r\n            }\r\n\r\n            profileContainer.wholeLayout.setOnClickListener {\r\n                findNavController().navigate(R.id.profile_action)\r\n            }\r\n\r\n            paymentMethodsContainer.wholeLayout.setOnClickListener {\r\n                findNavController().navigate(R.id.payment_methods_action)\r\n            }\r\n\r\n            addressesContainer.wholeLayout.setOnClickListener {\r\n                findNavController().navigate(R.id.user_addresses_action)\r\n            }\r\n\r\n            allergensContainer.wholeLayout.setOnClickListener {\r\n                findNavController().navigate(R.id.user_allergens_action)\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    override fun onDestroyView() {\r\n        super.onDestroyView()\r\n        _binding = null\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/kotlin/com/shakeshack/android/presentation/account/fragment/AccountOverviewFragment.kt	(revision 6396c08199df34293a1c2b5c227fa25e4f804cc7)
+++ app/src/main/kotlin/com/shakeshack/android/presentation/account/fragment/AccountOverviewFragment.kt	(date 1614002432074)
@@ -28,7 +28,7 @@
         inflater: LayoutInflater,
         container: ViewGroup?,
         savedInstanceState: Bundle?
-    ): View? {
+    ): View {
         _binding = FragmentAccountOverviewBinding.inflate(inflater, container, false)
         return binding.root
     }
@@ -42,6 +42,12 @@
             viewModel.getUserData(authToken)
         })
 
+        accountPreferences.oloAuthToken.asLiveData().observe(viewLifecycleOwner, Observer {
+            val oloAuthToken = it ?: return@Observer
+
+
+        })
+
         binding.apply {
 
             setUpToolbarFromFragment(toolbarContainer.toolbar)
